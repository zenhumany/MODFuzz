import time
import pickle
import logging
import angr
import os
import re
from important_global_data import *



def is_bad_name(name):
    badwords = ['sub_', 'asan', 'amd', 'ptrace']
    goodwords = ['usb', 'deref', 'attach', 'detach', 'urb', 'dev', 'port', 'core', 'interface', 'drive', 'bulk', 'hcd',
                 'gadget', 'msg', 'config', 'bus', 'prob', 'bind', 'remove', 'hub', 'stack']
    for i in badwords:
        if i in name:
            return True
    for i in goodwords:
        if i in name:
            return False
    return True



def get_funcs_from_dir(given_dir):
    dir_funcs_list = []
    dir_list = [given_dir]
    search_list = []
    for i in dir_list:
        search_list.append(c_source_file_prefix + i)
    file_list = []
    for i in search_list:
        for root, dirs, files in os.walk(i):
            for file in files:
                file_path = os.path.join(root, file)
                if file_path[-1] == 'c':
                    file_list.append(file_path)
    for i in file_list:
        dir_funcs_list += get_funcs_from_c_file(i)
    dir_funcs_list = list(set(dir_funcs_list))
    return len(dir_funcs_list)



def get_c_file_list_by_dir():
    dir_list = ['sound\\usb\\', 'drivers\\usb\\', 'drivers\\media\\usb\\']
    search_list = []
    for i in dir_list:
        search_list.append(c_source_file_prefix + i)
    file_list = []
    for i in search_list:
        for root, dirs, files in os.walk(i):
            for file in files:
                file_path = os.path.join(root, file)
                if file_path[-1] == 'c':
                    file_list.append(file_path)
    return file_list



def get_funcs_from_c_file(file_path):
    funcs_list = []
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    pattern1 = re.compile(r'\n[\w *\n\t]+\([\w\n *,\t]+\)\n{\n')
    pattern2 = re.compile(r'[ \n\t*][\w.]+[ \t\n]*\(')
    matches = re.findall(pattern1, content)
    for match in matches:
        func_name = re.findall(pattern2, match)
        if len(func_name) != 1:
            print("match error:", file_path, match)
        name = func_name[0].replace(' ', '').replace('(', '').replace('*', '').replace('\t', '').replace('\n', '')
        funcs_list.append(name)
    return funcs_list




def calc_call_rate(path):
    call_rate = 1
    for i in range(len(path) - 1):

        if path[i+1] in path[i].successors:
            if not path[i].has_return:
                call_rate *= 1 / len(path[i].successors)
            else:

                call_rate = 0

        else:
            # print(call_rate)
            pass
    # return len(call_graph.loc[call_graph['func_name'] == func_name])
    return call_rate



def get_gvar_range(kernel):
    logging.getLogger('angr').setLevel('CRITICAL')
    gvar_range_list = []
    for i in kernel.loader.main_object.sections.raw_list:
        if i.is_readable and i.is_writable and not i.is_executable and i.min_addr >= 0xffffffff80000000 \
                and i.name != '.rodata':
            couple = (i.min_addr, i.max_addr)
            gvar_range_list.append(list(couple))
    return gvar_range_list



def get_danger_gvar_list(kernel):
    logging.getLogger('angr').setLevel('CRITICAL')
    danger_gvar_list = []
    gvar_list = []
    section_area_list = get_gvar_range(kernel)
    symbols = list(kernel.loader.main_object.symbols)
    for i in symbols:
        for area in section_area_list:
            if area[0] <= i.rebased_addr <= area[1]:
                gvar_list.append(i)
    for i in gvar_list:
        if 'buf' in i.name or 'num' in i.name or 'len' in i.name:
            danger_gvar_list.append(i)
    return danger_gvar_list



def calc_complement(hex_num_str):
    num_bits = 64
    int_value = int(hex_num_str, 16)
    mask = (1 << num_bits) - 1
    if int_value & (1 << (num_bits - 1)):
        twos_complement = int_value | ~mask
    else:
        twos_complement = int_value
    twos_complement = hex(twos_complement & 0xFFFFFFFFFFFFFFFF)[2:].zfill(16)
    return twos_complement



def explore_addr_to_call(kernel, addr, danger_call_addr, gvar_danger_score, in_func, host_func_name, called_func_name):
    start_time = time.time()
    overtime = 0
    logging.getLogger('angr').setLevel('CRITICAL')
    if in_func == 1:
        timeout = 30
        print('It is func-begin symbolic execution!')
    else:
        timeout = 10
        print('It is block-begin symbolic execution!')
    score = 0
    state = kernel.factory.call_state(addr=addr)
    simgr = kernel.factory.simulation_manager(state)
    simgr.use_technique(angr.exploration_techniques.Timeout(timeout=timeout))
    # simgr.use_technique(angr.exploration_techniques.DFS())
    simgr.explore(find=danger_call_addr)
    explore_time = time.time() - start_time
    print('explore_time =', explore_time, simgr.found)
    if (in_func == 1 and explore_time > 19.9) or (in_func == 0 and explore_time > 9.9):
        print('time out!')
        overtime = 1
    if len(simgr.found) < 1 and in_func == 0:
        print('????????????????block-begin not reach call addr??????????????')
    if len(simgr.found) >= 1:
        found_state = simgr.found[0]
        gvar_range_list = get_gvar_range(kernel)

        reg_list = [found_state.regs.rdi, found_state.regs.rsi, found_state.regs.rdx, found_state.regs.rcx,
                    found_state.regs.r8, found_state.regs.r9]
        for reg in reg_list:

            if is_addr_in_gvar_range(found_state.solver.eval(reg), gvar_range_list) \
                    or reg.concrete is True:
                score += 1

        stack_top = list()
        stack_top.append(re_endian(hex(found_state.solver.eval(found_state.memory.load(found_state.regs.rsp, 8)))))
        stack_top.append(re_endian(hex(found_state.solver.eval(found_state.memory.load(found_state.regs.rsp + 8, 8)))))
        stack_top.append(re_endian(hex(found_state.solver.eval(found_state.memory.load(found_state.regs.rsp + 16, 8)))))
        stack_top.append(re_endian(hex(found_state.solver.eval(found_state.memory.load(found_state.regs.rsp + 24, 8)))))
        for stack_data in stack_top:
            if is_addr_in_gvar_range(int(stack_data, 16), gvar_range_list):
                score += 1
        if called_func_name in dangerous_funcs_full:
            score *= 2
    print('\'explore_addr_to_call\' total run time:%.3f s, score:%.1f' % (time.time() - start_time, score))
    print('host_func_name:', host_func_name)
    if host_func_name not in gvar_danger_score.keys():
        gvar_danger_score[host_func_name] = score
    else:
        gvar_danger_score[host_func_name] += score
    return overtime



def re_endian(num_str):
    if len(num_str) % 2 != 0:
        return '0x0'
    num_str = num_str[2:]
    num_str = list(num_str[::-1])
    for i in range(len(num_str)):
        if i % 2 == 0:
            tmp = num_str[i]
            num_str[i] = num_str[i+1]
            num_str[i+1] = tmp
    result = '0x' + ''.join(num_str)
    return result



def handle_timeout(process):
    if process.is_alive():
        print(process, "overtime, terminated!")
        process.terminate()



def load_cfg():
    with open("cfg_complete_scan_" + kernal_binary.split('\\')[-1] + '.pkl', 'rb') as file:
        cfg = pickle.load(file)
    return cfg



def load_r2_result():
    with open("r2_functions_result_" + kernal_binary.split('\\')[-1] + '.pkl', 'rb') as file:
        r2_functions_result = pickle.load(file)
    return r2_functions_result



def load_bin_symbol_table():
    with open("r2_bin_symbol_table_" + kernal_binary.split('\\')[-1] + '.pkl', 'rb') as file:
        bin_symbol_table = pickle.load(file)
    return bin_symbol_table



def is_addr_in_gvar_range(addr, gvar_range_list):
    for area in gvar_range_list:
        if area[0] <= addr <= area[1]:
            return True
    return False



def find_func_by_name_symboltable(func_name, bin_symbol_table):
    for sym in bin_symbol_table:
        if sym['name'] == func_name or sym['realname'] == func_name:
            print(hex(sym['vaddr']))



def write_result_to_afl():
    with open("funcs_vul_score_final" + kernal_binary.split('\\')[-1] + '.pkl', 'rb') as file:
        funcs_vul_score_final = pickle.load(file)
    txt = open('addr_score_afl.txt', 'w')
    bin_symbol_table = load_bin_symbol_table()
    for func in funcs_vul_score_final.keys():
        for sym in bin_symbol_table:
            if func == sym['realname'] and sym['type'] == 'FUNC' and \
                    funcs_vul_score_final[func]['func_vul_score'] != 0 and \
                    str(f"{funcs_vul_score_final[func]['func_vul_score']:.4f}") != '0.0000':
                txt.write(str(sym['vaddr']) + ':' +
                          str(sym['vaddr'] + sym['size']) + ":" +
                          str(f"{funcs_vul_score_final[func]['func_vul_score'] * 10:.4f}") + '\n')
                break
