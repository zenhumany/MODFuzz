
import networkx
from gadgets import *
import time
import pandas as pd
import logging
import copy
import pickle
from important_global_data import *


call_graph = pd.read_csv(csv_path)

logging.getLogger('angr').setLevel('CRITICAL')
kernel = angr.Project(kernal_binary, use_sim_procedures=False, auto_load_libs=False)
cfg = load_cfg()
r2_functions_result = load_r2_result()
bin_symbol_table = load_bin_symbol_table()


funcs_calc_list = []
funcs_calc_name_list = []
for i in cfg.kb.functions:
    cur_func = cfg.kb.functions[i]
    if not is_bad_name(cur_func.name):
        funcs_calc_name_list.append(cur_func.name)
        funcs_calc_list.append(i)

c_file_list = get_c_file_list_by_dir()
for file in c_file_list:
    funcs_list = get_funcs_from_c_file(file)
    for i in funcs_list:
        funcs_calc_name_list.append(i)
funcs_calc_name_list = list(set(funcs_calc_name_list))

count_for_funcs_calc_name_list = 0
for name in funcs_calc_name_list:
    for i in bin_symbol_table:
        if (i['realname'] == name or i['name'] == name) and i['type'] == 'FUNC':
            funcs_calc_list.append(i['vaddr'])
    count_for_funcs_calc_name_list += 1
    print(count_for_funcs_calc_name_list, '/', len(funcs_calc_name_list))
funcs_calc_list = list(set(funcs_calc_list))
funcs_calc_name_list = []
for i in funcs_calc_list:
    funcs_calc_name_list.append(cfg.kb.functions[i].name)
funcs_calc_name_list = list(set(funcs_calc_name_list))



start_time = time.time()
gvar_danger_score = dict()
gvar_range_list = get_gvar_range(kernel)
danger_gvar_list = get_danger_gvar_list(kernel)
xref_num = 0
count = 0

calculated_called_addrs = []
for danger_gvar in danger_gvar_list:
    xrefs = cfg.kb.xrefs.get_xrefs_by_dst(danger_gvar.rebased_addr)
    xref_num += len(xrefs)
for danger_gvar in danger_gvar_list:
    xrefs = cfg.kb.xrefs.get_xrefs_by_dst(danger_gvar.rebased_addr)
    for xref in xrefs:

        if not is_addr_in_gvar_range(xref.dst, gvar_range_list):
            count += 1
            print('dst of xref is not a gvar, pass!')
            print(str(count) + '/' + str(xref_num) + ' xref have been calculated, time passed',
                  time.time() - start_time)
            print('************************************************************************************************')
            continue

        if xref.type_string == 'write':
            count += 1
            print('xref type is write, pass!')
            print(str(count) + '/' + str(xref_num) + ' xref have been calculated, time passed',
                  time.time() - start_time)
            print('************************************************************************************************')
            continue
        func_addr = None
        for symbol in bin_symbol_table:

            if symbol['type'] == 'FUNC' and symbol['size'] <= 0xfffffff000000000 and \
                    symbol['vaddr'] <= xref.block_addr <= symbol['vaddr'] + symbol['size'] <= 0xffffffff86a25fff:
                func_addr = symbol['vaddr']
                break

        if func_addr is None:
            func_addr = cfg.model.get_any_node(xref.block_addr).function_address
        host_func = cfg.kb.functions[func_addr]
        host_func_name = host_func.name
        block = kernel.factory.block(xref.block_addr)

        calculated = 0
        if block.capstone.insns[-1].mnemonic == 'call':
            danger_call_addr = block.capstone.insns[-1].address
            if danger_call_addr not in calculated_called_addrs:
                block_node = cfg.model.get_any_node(xref.block_addr)

                called_node = cfg.model.get_any_node(int(block.capstone.insns[-1].op_str, 16))
                called_func_name = called_node.name
                # if called_func_name not in dangerous_funcs_full:
                #     count += 1
                #     print('called_func_name is not dangerous, pass!')
                #     print(str(count) + '/' + str(xref_num) + ' xref have been calculated, time passed',
                #           time.time() - start_time)
                #     print('**********************************************************************'
                #           '**************************')
                #     continue


                overtime = explore_addr_to_call(kernel, func_addr, danger_call_addr,
                                                gvar_danger_score, 1, host_func_name, called_func_name)

                if overtime == 1:
                    print("func_begin symbolic execution overtime!", xref)
                    overtime = explore_addr_to_call(kernel, xref.block_addr, danger_call_addr,
                                                    gvar_danger_score, 0, host_func_name, called_func_name)
                    if overtime == 1:
                        print('Both func and block-begin symbolic execution failed!', xref)
                calculated_called_addrs.append(danger_call_addr)
            calculated = 1
        count += 1
        if calculated == 0:
            print('no call after gvar reference, pass!')
        print(str(count) + '/' + str(xref_num) + ' xref have been calculated, time passed',
              time.time() - start_time)
        print('************************************************************************************************')
gvar_danger_score_backup = copy.deepcopy(gvar_danger_score)
for i in gvar_danger_score_backup.keys():
    if gvar_danger_score[i] == 0:
        del gvar_danger_score[i]
gvar_danger_score = dict(sorted(gvar_danger_score.items(), key=lambda x: x[1], reverse=True))



start_time = time.time()
funcs_vul_score = dict()
for i in funcs_calc_list:
    cur_func = cfg.kb.functions[i]
    # if 'sub_' in cur_func.name:
    #     continue
    USBfuncs_distance_score = 0
    dangerfuncs_distance_score = 0
    source_node = cfg.model.get_any_node(cur_func.addr)
    for target_func in USB_strong_related_funcs:
        if kernel.loader.find_symbol(target_func) is None:
            continue
        target_node = cfg.model.get_any_node(kernel.loader.find_symbol(target_func).rebased_addr)
        try:
            paths = list(networkx.all_shortest_paths(G=cfg.graph, source=source_node, target=target_node,
                                                     method='dijkstra'))
            for path in paths:
                # if len(path) <= 7:
                USBfuncs_distance_score += 1 * calc_call_rate(path) * 0.7
            # path = networkx.shortest_path(G=cfg.graph, source=source_node, target=target_node)
            # USBfuncs_distance_score += 1 * calc_call_rate(path) * 0.7
        except Exception as e:
            if "cannot be reachedfrom given sources" in str(e):
                # print('A unreachable exception between ' + source_node.name + ' and ' + target_node.name)
                pass
            else:
                print(e)

    for target_func in USB_weak_related_funcs:
        if kernel.loader.find_symbol(target_func) is None:
            continue
        target_node = cfg.model.get_any_node(kernel.loader.find_symbol(target_func).rebased_addr)
        try:
            paths = list(networkx.all_shortest_paths(G=cfg.graph, source=source_node, target=target_node,
                                                     method='dijkstra'))
            for path in paths:
                # if len(path) <= 7:
                USBfuncs_distance_score += 1 * calc_call_rate(path) * 0.3
            # path = networkx.shortest_path(G=cfg.graph, source=source_node, target=target_node)
            # USBfuncs_distance_score += 1 * calc_call_rate(path) * 0.3
        except Exception as e:
            if "cannot be reachedfrom given sources" in str(e):
                # print('A unreachable exception between ' + source_node.name + ' and ' + target_node.name)
                pass
            else:
                print(e)

    for target_func in dangerous_funcs:
        if kernel.loader.find_symbol(target_func) is None:
            continue
        target_node = cfg.model.get_any_node(kernel.loader.find_symbol(target_func).rebased_addr)
        try:
            paths = list(networkx.all_shortest_paths(G=cfg.graph, source=source_node, target=target_node,
                                                     method='dijkstra'))
            for path in paths:
                # if len(path) <= 5:
                # print(calc_call_rate(path), target_func)
                dangerfuncs_distance_score += 1 * calc_call_rate(path)
            # path = networkx.shortest_path(G=cfg.graph, source=source_node, target=target_node)
            # dangerfuncs_distance_score += 1 * calc_call_rate(path)
        except Exception as e:
            if "cannot be reachedfrom given sources" in str(e):
                # print('A unreachable exception between ' + source_node.name + ' and ' + target_node.name)
                pass
            else:
                print(e)
    # if USBfuncs_distance_score <= 0.1:
    #     vul_score = dangerfuncs_distance_score * 0.3 + USBfuncs_distance_score * 7
    # else:
    #     vul_score = dangerfuncs_distance_score * 3 + USBfuncs_distance_score * 7
    vul_score = dangerfuncs_distance_score * USBfuncs_distance_score
    # print('************************************************************************************************')
    score_triplet = {'func_vul_score': vul_score,
                     'USBfuncs_distance_score': USBfuncs_distance_score,
                     'dangerfuncs_distance_score': dangerfuncs_distance_score}
    funcs_vul_score[cur_func.name] = score_triplet
    print(str(len(funcs_vul_score)) + '/' + str(len(funcs_calc_name_list)),
          "Time passed", str(time.time() - start_time) + "s, ", cur_func.name + ":", funcs_vul_score[cur_func.name])

funcs_vul_score = dict(sorted(funcs_vul_score.items(), key=lambda x: x[1]['func_vul_score'], reverse=True))


funcs_vul_score_final = copy.deepcopy(funcs_vul_score)
for i in gvar_danger_score.keys():
    for j in funcs_vul_score.keys():
        if i == j:

            funcs_vul_score_final[i]['gvar_danger_score'] = gvar_danger_score[i]
            funcs_vul_score_final[i]['func_vul_score'] += \
                funcs_vul_score_final[i]['dangerfuncs_distance_score'] * gvar_danger_score[i] * 0.1 * \
                funcs_vul_score_final[i]['USBfuncs_distance_score']
funcs_vul_score_final = dict(sorted(funcs_vul_score_final.items(), key=lambda x: x[1]['func_vul_score'], reverse=True))

with open("funcs_vul_score_final" + kernal_binary.split('\\')[-1] + '.pkl', 'wb') as file:
    pickle.dump(funcs_vul_score_final, file)

